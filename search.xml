<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>零</title>
      <link href="/DriedMushroomBlog/2026/01/24/%E9%9B%B6/"/>
      <url>/DriedMushroomBlog/2026/01/24/%E9%9B%B6/</url>
      
        <content type="html"><![CDATA[<p>你好。再见。</p><div class="note info flat"><p>经典台词：“生活就像一盒巧克力，你永远不知道下一颗是什么味道。”</p></div>]]></content>
      
      
      <categories>
          
          <category> 作死记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 作死记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从流水线到微系统</title>
      <link href="/DriedMushroomBlog/2026/01/23/%E4%BB%8E%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%88%B0%E5%BE%AE%E7%B3%BB%E7%BB%9F/"/>
      <url>/DriedMushroomBlog/2026/01/23/%E4%BB%8E%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%88%B0%E5%BE%AE%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>经过 P6，我们已经得到了一个功能较为齐全且正确（假设）的流水线 <code>Cpu</code>（💀瑟瑟发抖了），然而它现在还存在两个很严重的问题：一是鲁棒性不足，<code>code</code> 有错误就寄了；二是无法与外界交互，只能运行预制的代码。</p><p>在这一节，我们要把从 P6 带来的 <code>Cpu</code> 封装成一个可与外界交互的微系统，并增添异常处理功能。</p><h5 id="约定："><a href="#约定：" class="headerlink" title="约定："></a>约定：</h5><ul><li><p>本文中提到的 <strong>异常</strong> 均为 <code>Cpu</code> 运行代码时发生的异常，<strong>中断</strong> 均为来自外界（<code>Timer</code> 和 <code>tb</code>）的中断，这是两个完全不同的概念，<strong>异常中断</strong> 是指 <strong>异常</strong> 与 <strong>中断</strong>，而非异常造成的中断或者别的什么。</p></li><li><p><code>Cp0</code> 置于 <code>M</code> 级（后面会解释为什么）。</p></li><li><p>我的实现宗旨并非能转发尽转发，我只处理了我认为恰当的转发。涉及到可以转发但我认为没必要的会说明，保证我的实现不会超时，但不保证把我提到的转发全部实现不会因运行周期过少而无法通过。</p></li><li><p>我采用分布式译码，涉及到集中式译码和分布式译码有差别的我会尽可能说明。</p></li><li><p>我管控制单元（有人叫 <code>Ctrl Unit</code> 或者 <code>CU</code>）叫 <code>Mainctrl_X</code></p></li></ul><hr><h4 id="这里提供一种可行的实现顺序"><a href="#这里提供一种可行的实现顺序" class="headerlink" title="这里提供一种可行的实现顺序"></a>这里提供一种可行的实现顺序</h4><ul><li><p>实现各流水级的异常判定逻辑，产出异常码，并流水至 <code>M</code> 级 （我的 <code>Cp0</code> 所在级别）</p></li><li><p>实现内部异常的容忍：这是汇报异常同时在产出异常的流水级执行的操作 </p></li><li><p>实现 <code>Cp0</code></p></li><li><p>陷入内核</p><ul><li>流水 <code>BD</code> </li><li>实现各级流水线（其实是 <code>Dm</code>、<code>Mdu</code>、<code>Grf</code>）对 <code>Req</code> 的响应</li><li>调整流水线寄存器的清空逻辑（<code>reset &gt; Req &gt; stall/flush</code>）</li><li>跳转到异常处理程序</li></ul></li><li><p>桥与整体架构（<code>mips.v</code>）</p></li><li><p>加指令（<code>syscall</code>、<code>nop</code>、<code>mfc0</code>、<code>mtc0</code>、<code>eret</code>）</p></li></ul><h4 id="异常判定逻辑（最简单一步）与流水"><a href="#异常判定逻辑（最简单一步）与流水" class="headerlink" title="异常判定逻辑（最简单一步）与流水"></a>异常判定逻辑（最简单一步）与流水</h4><hr><h6 id="异常判定逻辑："><a href="#异常判定逻辑：" class="headerlink" title="异常判定逻辑："></a>异常判定逻辑：</h6><p>在 <code>F</code>、<code>D</code>、<code>E</code>、<code>M</code> 级各选择一个顺眼的元件来输出异常码，没有硬性要求，想单设一个小工厂也可以，甚至想在 <code>cpu.v</code> 里直接设置都可以（只要你足够了解自己的实现）。我选择的是 <code>Pc</code>、<code>MainCtrl_D</code>、<code>Alu</code>、<code>Cp0/StoreCtrl/LoadCtrl</code>（课下没有要在 <code>M</code> 级判断的异常，但课上很可能有，要提前想好）。</p><p>我的异常码命名全是 元件名 + <code>excCode</code> </p><ul><li>__<code>F</code> 级：__只存在一种异常：<code>Pc</code> 值非法。非常的简单：</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> Pc_excCode = ((pc[<span class="number">1</span>:<span class="number">0</span>] != <span class="number">2&#x27;b00</span>) || (pc &lt; <span class="number">32&#x27;h3000</span>) || (pc &gt; <span class="number">32&#x27;h6fff</span>)) ? `AdEl : <span class="number">5&#x27;b00</span>;</span><br></pre></td></tr></table></figure><ul><li><strong><code>D</code> 级：</strong> 存在两种异常（两个异常码）：<code>syscall</code> 指令与陌生指令。宏定义这里就不做解释了。</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> MainCtrl_excCode = (<span class="keyword">type</span> == `SYSCALL) ? `Syscall :</span><br><span class="line">                          (<span class="keyword">type</span> == `UNKNOWN) ? `RI :</span><br><span class="line">                          <span class="number">5&#x27;b00</span>;</span><br></pre></td></tr></table></figure><ul><li><p>__<code>E</code> 级：__三个异常码十种异常：</p><ul><li><p>先添加一些辅助线：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> load  = (<span class="keyword">type</span> == `LW) || (<span class="keyword">type</span> == `LH) || (<span class="keyword">type</span> == `LB);</span><br><span class="line"><span class="keyword">wire</span> store = (<span class="keyword">type</span> == `SW) || (<span class="keyword">type</span> == `SH) || (<span class="keyword">type</span> == `SB);</span><br><span class="line"><span class="keyword">wire</span> add_overflow = (aluOp == ADD) &amp;&amp; (inA[<span class="number">31</span>] == inB[<span class="number">31</span>] &amp;&amp; inA[<span class="number">31</span>] != res[<span class="number">31</span>]);</span><br><span class="line"><span class="keyword">wire</span> sub_overflow = (aluOp == SUB) &amp;&amp; (inA[<span class="number">31</span>] != inB[<span class="number">31</span>] &amp;&amp; inA[<span class="number">31</span>] != res[<span class="number">31</span>]);</span><br><span class="line"><span class="keyword">wire</span> overflow = add_overflow || sub_overflow;</span><br></pre></td></tr></table></figure><p>判断计算溢出的方式看个人爱好，我喜欢简单一点的🎃，通常（如指令集）采用加宽一位判断 <code>res[32] != res[31]</code> 的办法</p></li><li><p>先上最简单的，<strong>计算溢出异常</strong>，涉事指令只有 <code>add, addi, sub</code></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> Ov_Exception = overflow &amp;&amp; (<span class="keyword">type</span> == `ADD || <span class="keyword">type</span> == `ADDI || <span class="keyword">type</span> == `SUB);</span><br></pre></td></tr></table></figure><blockquote><p>我这里是参考 <code>Kamonto</code> 学长的博客直接把所有指令的种类 <code>type</code> 给从头到尾流水了，用起很方便【感恩】。如果不想这么做，需要在 <code>MainCtrl</code> 输出一个 <code>mayOverFlow</code> 表示指令类型为 <code>add || addi || sub</code> 并（集中式译码的话）流水到 <code>E</code> 级</p></blockquote><ul><li><p>剩下两个都是硬骨头了，先加个地址异常的辅助线（<del>好自由的地址！^_^</del>）🪁</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> addrFlyingAway = (res &lt; <span class="number">32&#x27;h0000_7F00</span> || res &gt; <span class="number">32&#x27;h0000_7F0B</span>) &amp;&amp; <span class="comment">// 不在 Timer0 范围内</span></span><br><span class="line">  (res &lt; <span class="number">32&#x27;h0000_7F10</span> || res &gt; <span class="number">32&#x27;h0000_7F1B</span>) &amp;&amp; <span class="comment">// 不在 Timer1 范围内</span></span><br><span class="line">  (res &lt; <span class="number">32&#x27;h0000_0000</span> || res &gt; <span class="number">32&#x27;h0000_2FFF</span>) &amp;&amp; <span class="comment">// 不在 Im、DM 范围内</span></span><br><span class="line">  (res &lt; <span class="number">32&#x27;h0000_7F20</span> || res &gt; <span class="number">32&#x27;h0000_7F23</span>);   <span class="comment">// 不在 中断发生器 范围内</span></span><br></pre></td></tr></table></figure><p>地址别写错了…… 可以直接复制我的地址&#x2F;和我的地址对一对</p><ul><li><code>Lw</code> <code>LH</code> 地址没对齐</li><li><code>LH</code> <code>LB</code> 读&#x2F;写计时器（只有 <code>LW</code> 允许读&#x2F;写计时器，因为人家是按字存储的）</li><li>地址计算溢出（溢出后的得数单独看很可能合法的，所以这个不能并入下一条）</li><li>访问非法地址（即上面那个 <code>addrFlyingAway</code>）</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> AdEl_Exception = (res[<span class="number">1</span>:<span class="number">0</span>] != <span class="number">2&#x27;b00</span>)                            &amp;&amp; (<span class="keyword">type</span> == `LW) ||</span><br><span class="line">                      (res[<span class="number">0</span>] != <span class="number">1&#x27;b0</span>)                               &amp;&amp; (<span class="keyword">type</span> == `LH) ||  </span><br><span class="line">                      (res &gt;= <span class="number">32&#x27;h0000_7F00</span> &amp;&amp; res &lt;= <span class="number">32&#x27;h0000_7F0B</span>) &amp;&amp; (<span class="keyword">type</span> == `LH) ||</span><br><span class="line">                      (res &gt;= <span class="number">32&#x27;h0000_7F10</span> &amp;&amp; res &lt;= <span class="number">32&#x27;h0000_7F1B</span>) &amp;&amp; (<span class="keyword">type</span> == `LH) ||</span><br><span class="line">  (res &gt;= <span class="number">32&#x27;h0000_7F00</span> &amp;&amp; res &lt;= <span class="number">32&#x27;h0000_7F0B</span>) &amp;&amp; (<span class="keyword">type</span> == `LB) ||</span><br><span class="line">                      (res &gt;= <span class="number">32&#x27;h0000_7F10</span> &amp;&amp; res &lt;= <span class="number">32&#x27;h0000_7F1B</span>) &amp;&amp; (<span class="keyword">type</span> == `LB) ||</span><br><span class="line">                      add_overflow                                   &amp;&amp; load ||  </span><br><span class="line">                      addrFlyingAway                                 &amp;&amp; load;  </span><br></pre></td></tr></table></figure><p><code>AdEs</code> 比 <code>AdEl</code> 多一个不能写 <code>Timer</code> 的 <code>counter</code> 的要求</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> AdEs_Exception = (res[<span class="number">1</span>:<span class="number">0</span>] != <span class="number">2&#x27;b00</span>)                            &amp;&amp; (<span class="keyword">type</span> == `SW) ||</span><br><span class="line">                      (res[<span class="number">0</span>] != <span class="number">1&#x27;b0</span>)                               &amp;&amp; (<span class="keyword">type</span> == `SH) ||  </span><br><span class="line">                      (res &gt;= <span class="number">32&#x27;h0000_7F00</span> &amp;&amp; res &lt;= <span class="number">32&#x27;h0000_7F0B</span>) &amp;&amp; (<span class="keyword">type</span> == `SH) ||</span><br><span class="line">                      (res &gt;= <span class="number">32&#x27;h0000_7F10</span> &amp;&amp; res &lt;= <span class="number">32&#x27;h0000_7F1B</span>) &amp;&amp; (<span class="keyword">type</span> == `SH) ||</span><br><span class="line">                      (res &gt;= <span class="number">32&#x27;h0000_7F00</span> &amp;&amp; res &lt;= <span class="number">32&#x27;h0000_7F0B</span>) &amp;&amp; (<span class="keyword">type</span> == `SB) ||</span><br><span class="line">                      (res &gt;= <span class="number">32&#x27;h0000_7F10</span> &amp;&amp; res &lt;= <span class="number">32&#x27;h0000_7F1B</span>) &amp;&amp; (<span class="keyword">type</span> == `SB) ||</span><br><span class="line">                      (res &gt;= <span class="number">32&#x27;h0000_7F08</span> &amp;&amp; res &lt;= <span class="number">32&#x27;h0000_7F0B</span>) &amp;&amp; store ||</span><br><span class="line">                      (res &gt;= <span class="number">32&#x27;h0000_7F18</span> &amp;&amp; res &lt;= <span class="number">32&#x27;h0000_7F1B</span>) &amp;&amp; store ||</span><br><span class="line">                      add_overflow                                   &amp;&amp; store ||</span><br><span class="line">                      addrFlyingAway                                 &amp;&amp; load;  </span><br></pre></td></tr></table></figure><p>还是，千万别写错了，这玩意儿写错了真没法 <code>de</code>，甚至课下都不一定能测的出来。</p></li></ul></li></ul></li></ul><p>​最后合一下，这些异常不会同时发生，没有优先级的顾虑：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> Alu_excCode = Ov_Exception ? `Ov :</span><br><span class="line">                     AdEl_Exception ? `AdEl :</span><br><span class="line">                     AdEs_Exception ? `AdEs :</span><br><span class="line">                     <span class="number">5&#x27;b00</span>;</span><br></pre></td></tr></table></figure><h6 id="流水-excCode："><a href="#流水-excCode：" class="headerlink" title="流水 excCode："></a>流水 <code>excCode</code>：</h6><p>当前不存在同一条指令触发的不同异常优先级不同的情况，所有异常均遵循先触发的优先级更高的原则，即：同一指令，在靠前的流水级触发的异常优先级更高；不同指令，靠前的指令（先执行的指令）触发的异常优先级更高。基本上是这个形式：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">excCode_X = (excCode_[X - <span class="number">1</span>]) ? excCode_[X - <span class="number">1</span>] : [X 级元件]_excCode;</span><br></pre></td></tr></table></figure><h4 id="内部异常的容忍"><a href="#内部异常的容忍" class="headerlink" title="内部异常的容忍"></a>内部异常的容忍</h4><hr><p>在 <strong>thysrael</strong> 学长的博客里看到这个叫法，感觉非常有感觉。</p><p>其实就是两件事，所有<code>F</code> 、<code>D</code> 级发现的受害指令经过 <code>D_E</code> 变空泡，所有异常指令经过 <code>M_W</code> 变空泡（这个后面提怎么实现）。</p><p>不骗你，就这两件事没别的了。以及，这是个人认为最好（简洁 + 安全）的实现方式。</p><p>当然有很多很多实现方法，比如只禁掉写使能不变空泡，但哪儿有直接清空来得方便？（无论是哪种译码方式）</p><p>__为什么不一旦检测到异常就变空泡呢？__危险，这是因为同一条指令可能在不同流水级触发优先级不同的异常，万一后面的流水级涉及到更高级别的异常呢？结果人家等了半天就见一个空泡摇摇晃晃地浮上来，销毁所有犯罪证据 v_v，一看就是有问题。（暂时没有，保不齐课上加）</p><p><strong>为什么经过 <code>M_W</code></strong> 要变空泡呢？首先 <code>W</code>  级不可能加异常，所以我们可以安心的放一个空泡过去。<code>W</code> 级在 <code>Cp0</code> 之后（不管你 <code>Cp0</code> 在哪个流水级都是这样），<code>Cp0</code> 是去解决异常了，但它不解决异常指令啊，如果不管的话，还是会放一个已经 “记录在案” 的受害指令过去大闹 <code>W</code> 级（乱写 <code>Grf</code>）。</p><p><strong>怎么实现？</strong> 前一个在 <code>D_E</code> 里加 <code>excCode != 0</code> 则 <code>inStr_ &lt;= 0</code> 即可，后一个跟所有其他流水线寄存器一样 <code>Req</code> 清零就行，但要知道这和其它流水线寄存器清零的原理并不一样）。 </p><h4 id="流水寄存器和元件在-Req-时的行为"><a href="#流水寄存器和元件在-Req-时的行为" class="headerlink" title="流水寄存器和元件在 Req 时的行为"></a>流水寄存器和元件在 <code>Req</code> 时的行为</h4><hr><p>这里插播一条（其实放这里不合适，但便于理解）</p><p>上文提到，出于不同原因，所有流水线寄存器遇到 <code>Req</code> 都要清空，原因有两种：</p><ul><li><p>对于 <code>M_W</code>： 是为了防止已经 “记录在案” 的受害指令过去大闹 <code>W</code> 级（乱写 <code>Grf</code>）。</p></li><li><p>对于其它流水线寄存器： 是为了清空流水线，好让异常处理指令进来。以及保证 “受害指令及其后面的指令像没发生过一样”</p></li></ul><h5 id="怎么实现清空流水线寄存器？"><a href="#怎么实现清空流水线寄存器？" class="headerlink" title="怎么实现清空流水线寄存器？"></a>怎么实现清空流水线寄存器？</h5><p>流水线寄存器里现在有一大堆控制信号了：<code>reset, Req, stall, flush</code>（最后一个是方便 P6 课上加指令清空延迟槽的），它们的优先级是怎样的？<code>Reset</code> 是要关机重启了，它最大。<code>Req</code> 是要给异常处理程序腾地方了，都清空了还阻塞什么？所以它次之。剩下两个 <code>stall &gt; flush</code> 大家已经知道了（不然能过 P5 只能说很幸运），所以：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reset &gt; Req &gt; stall &gt; flush</span><br></pre></td></tr></table></figure><p>另外，如果你已经做了思考题，你会发现有一道题目（我们这届的）叫做 <strong>在清空流水线寄存器的时候需要保留什么？</strong></p><blockquote><p>5、倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？</p></blockquote><p>按照我 <code>P6</code> 的实现，宏观 <code>Pc</code> 会冷不丁变成 0x3000 一小会儿   ……<small>无关言论</small>……   替换的空泡指令应继承原指令的 <code>Pc</code>，插入的空泡指令应流水下一条指令相同的 <code>Pc</code>，插入在被阻塞的延迟槽指令前的空泡应继承该延迟槽指令的 <code>BE</code></p><p>具体实现为空泡前流水线寄存器中的 <code>BE</code> 和 <code>Pc</code> 都正常流水</p><h5 id="元件在-Req-时的行为："><a href="#元件在-Req-时的行为：" class="headerlink" title="元件在 Req 时的行为："></a>元件在 <code>Req</code> 时的行为：</h5><ul><li><p>禁止写内存</p><p>这个好实现，但请务必选择一个可扩展性好的方式，便于课上加指令，比如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> memWrEn = &#123;</span><br><span class="line">    (! Req) &amp;&amp; &#123;……&#125;,</span><br><span class="line">    (! Req) &amp;&amp; &#123;……&#125;,</span><br><span class="line">    (! Req) &amp;&amp; &#123;……&#125;,</span><br><span class="line">    (! Req) &amp;&amp; &#123;……&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>封闭乘除槽</p><p>必须禁止进入，至于原本就在乘除槽里的，在 <code>Req</code> 那一个周期，停掉也可以，继续算也可以，不差那点效率</p><p><strong>注意！</strong> 我一开始投机取巧，觉得先给 <code>HI/LO</code> 赋值，回来再倒计时是一样的，但 <code>WA</code> 了，因为异常处理程序里也有读写 <code>HI/LO</code></p></li></ul><h4 id="Cp0"><a href="#Cp0" class="headerlink" title="Cp0"></a>Cp0</h4><hr><p><code>Cp0</code> 里有很多寄存器，我们只要求实现了一部分功能，所以只设置需要的那部分就可以（目前就只有三个）。</p><p>如下图，即使是这三个需要的寄存器，也只是需要其中的部分位，其余无关位初始化为 0，然后 除非 <code>ntc0</code> 写它们否则不去动它们就好。</p><p>虽然理论上说无关位恒为 0 禁止写入甚至干脆不实现都可以，但我没试过，不知道能不能通过评测。</p><img src="https://cdn.luogu.com.cn/upload/image_hosting/nuxb6sf9.png" style="zoom:40%;" /><h4 id="陷入内核"><a href="#陷入内核" class="headerlink" title="陷入内核"></a>陷入内核</h4><hr><h5 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h5><ul><li><p><code>Epc</code></p><p>异常处理程序不是我们该关心的，我们默认异常处理程序会解决当前问题（即让受害指令不再产生异常、可以正常执行），所以需要保证跳回到当前指令重新执行当前指令。</p><p>但实际上，异常处理程序有可能无法解决（或者懒得解决）当前问题，这时它解决问题的方式就变成了把我们传给他的 EPC 加上4（跳过异常指令）。</p><p>但跳过异常指令属于 ”解决异常的一部分“，这不是我们该关心的，所以我们必须默认 EPC 可以重新执行受害指令。</p><p><strong>综上所述</strong>，<code>Epc</code> 就是 <code>Cp0</code> 级 <code>Pc</code>。</p></li><li><p><code>excCode</code></p></li></ul><h5 id="跳转到异常处理程序"><a href="#跳转到异常处理程序" class="headerlink" title="跳转到异常处理程序"></a>跳转到异常处理程序</h5><p>这里的跳转和我们过去实现的跳转不同。</p><p>首先它没有延迟槽一说，因为 </p><blockquote><p>受害指令及其后的指令像没发生过一样</p></blockquote><p>被人道主义消灭了。</p><p>其次是 <code>Req</code> 在 <code>M</code> 级的时候跳转，那它肯定不能加入 <code>D</code> 级的跳转大军了。</p><p>所以只需要在 <code>Req</code> 为 1 时将 <code>Npc</code> 的输出设为 <code>0x4180</code> 即可（这里不需要管 <code>Pc</code>，至少和我一样 <code>Npc</code> 是纯组合逻辑的话不用管）。</p><blockquote><p>另外所有流水寄存器（除了 <code>M_W</code> 无所谓）的 <code>pc</code> 都要同时同步成 <code>0x4180</code> 喔，不然会出现宏观 <code>Pc</code> 在 <code>Req</code> 之后又溜出去一段的诡异情景。</p></blockquote><h5 id="跳回来"><a href="#跳回来" class="headerlink" title="跳回来"></a>跳回来</h5><p>指导书里强调了</p><blockquote><p><code>eret</code> 没有延迟槽，你需要确保 <code>eret</code> 的下一条指令不被执行。</p></blockquote><p>这里至少有两种实现方式，<strong>注意</strong> 虽然这两种方式都可以通过评测，但在对拍时会因为周期数不同而出现报错（至少伟大的 <code>COT</code> 是这样），可以把两种都实现为了对拍🐸。</p><p><strong>第一种，清空延迟槽</strong>。这是比较正统的思路，可以合并进过去的跳转逻辑的。如果不考虑延迟槽，这个 <code>eret</code> 和 <code>jr</code> 太像了，唯一的区别就是目的地寄存器是从 <code>Cp0</code> 直连过来的 <code>Epc</code>，所以像 <code>jr</code> 一样实现就可以了。然后要清空延迟槽，相信已经通过 p5P6 的各位对此已经很熟悉了。</p><p><strong>第二种，偷周期（偷了整整一个周期）。</strong> 这属于邪修了，既然当 <code>D</code> 级是 <code>eret</code> 时，<code>F</code> 级的延迟槽指令我们不要了，那把它偷偷换成 <code>Epc</code> 指令不就行了？只需要在 <code>D</code> 级译码出来 <code>eret</code> 的时候，悄悄把 <code>Pc</code> （模块）传出来的 <code>Pc</code> 值换成 <code>Epc</code> 就好了，反正原本的 <code>F</code> 级指令已经被抛弃了。这样偷天换日，都不用改 <code>Pc</code> 和 <code>Npc</code>。在下个周期 <code>Npc</code> 会根据我们偷换的 <code>Pc</code> 计算 <code>Pc + 4</code>，实现了无缝衔接。</p><img src="https://cdn.luogu.com.cn/upload/image_hosting/xjdg3wdu.png" style="zoom:33%;" /><h4 id="加指令和数据冲突和阻塞和转发"><a href="#加指令和数据冲突和阻塞和转发" class="headerlink" title="加指令和数据冲突和阻塞和转发"></a>加指令和数据冲突和阻塞和转发</h4><hr><p>加指令的基础操作略，直接看阻塞&#x2F;转发。唯一的数据冲突就是 <code>mtc0</code> 在 <code>M</code> 级写 <code>Epc</code> 的时候，或者 <code>mtc0</code> 在 <code>E</code> 级的时候，<code>D</code> 级出现了 <code>eret</code>。</p><h6 id="全速转发"><a href="#全速转发" class="headerlink" title="全速转发"></a>全速转发</h6><p>为了速度，悲痛欲绝地决定增加转发通路：</p><h6 id="全阻塞"><a href="#全阻塞" class="headerlink" title="全阻塞"></a>全阻塞</h6><p>事实证明是能过的。</p><h6 id="M-D-转发，E-D-阻塞"><a href="#M-D-转发，E-D-阻塞" class="headerlink" title="M-D 转发，E-D 阻塞"></a><code>M-D</code> 转发，<code>E-D</code> 阻塞</h6><p>这是我选择的，折中的实现方式。读和写的都是 <code>Epc</code>，在 <code>Cp0</code> 内部转发就好了，这个比阻塞还好实现：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cp0.v</span></span><br><span class="line"><span class="keyword">assign</span> EpcOut = (wrEn &amp;&amp; (cp0Addr == <span class="number">5&#x27;b01110</span>)) ? cp0In : EPC;</span><br></pre></td></tr></table></figure><p>提前把要写的东西抢到手。</p><h4 id="桥与外设"><a href="#桥与外设" class="headerlink" title="桥与外设"></a>桥与外设</h4><hr><h6 id="桥"><a href="#桥" class="headerlink" title="桥"></a>桥</h6><p>我理解出来的是，要把 <code>Cpu</code> 对外隐藏实现细节，封装成单周期，然后把单周期封装成 <code>mips</code>，对外隐藏内部接线，只通过桥与外界沟通。但这样涉及到一些问题，比如 <code>Timer</code>，它肯定算外设毋庸置疑，但它该不该通过桥与 <code>cpu</code> 相连通？</p><p>指导书的配图是类似这样的：</p><img src="https://cdn.luogu.com.cn/upload/image_hosting/c46tn1om.png" style="zoom:33%;" /><p><strong>封装了又好像没封装</strong>，基本上只有 <code>tb</code> 是通过桥与 <code>Cpu</code> 相连通的，<code>Timer</code>、中断器什么的都直接连在 <code>Cpu</code> 上了。这样真的能起到系统桥的作用吗❓❔万一我要改 <code>IM</code>，岂不是还要改 <code>Cpu</code> 的接口？</p><p>我最后的实现是这样的：</p><img src="https://cdn.luogu.com.cn/upload/image_hosting/4p16m9ui.png" style="zoom:33%;" /><p>就是，完全封装了。</p><h6 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h6><img src="https://cdn.luogu.com.cn/upload/image_hosting/2c4pjv98.png" style="zoom:33%;" /><h2 id="往年题"><a href="#往年题" class="headerlink" title="往年题"></a><center>往年题</center></h2><p>P7 没有推荐题，这让人有点忧伤，特别是在群魔乱舞的 P7，不提交是不太能确认自己的实现是否正确的，但还是可以对一下的👁️。这里整理了我找到的全部往年题和我的实现。</p><h6 id="Tiltiu"><a href="#Tiltiu" class="headerlink" title="Tiltiu"></a>Tiltiu</h6><p>不要被 <code>trap</code> 骗了，我们是不会考得这么简单的 v_v</p><h6 id="Withdraw"><a href="#Withdraw" class="headerlink" title="Withdraw"></a>Withdraw</h6><h6 id="Watch"><a href="#Watch" class="headerlink" title="Watch"></a>Watch</h6><h6 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h6>]]></content>
      
      
      <categories>
          
          <category> CO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/DriedMushroomBlog/2026/01/23/hello-world/"/>
      <url>/DriedMushroomBlog/2026/01/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
